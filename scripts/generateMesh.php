{
  /**
   * Generated by scripts/generateMesh.php - do not edit manually
   * https://github.com/Apotheneum/Apotheneum
   */

  "label": "Apotheneum-Mesh",
  "tag": "apotheneumMesh",
  "parameters": {
    "nodeSpacing": { "type": "float", "min": 1, "default": 9.375, "label": "Spacing", "description": "Spacing of nodes" },
    "nodeInset": { "type": "float", "min": 1, "default": 15.8125, "label": "Inset", "description": "Inset of side nets in inches" },
    "cubeTop": { "type": "float", "min": 1, "default": 444, "label": "Top", "description": "Top of the cube LED nets in inches" },
    "cubeSide": { "type": "float", "min": 1, "default": 491, "label": "Side", "description": "Side of the cube in inches" },
    "cylinderRadius": { "type": "float", "min": 1, "default": 180, "label": "Radius", "description": "Radius of the cylinder in inches" },
    "meshInset": { "type": "float", "min": 1, "default": 1, "label": "Mesh Inset", "description": "Inset of the mesh behind nets" },
    "meshWidth": { "type": "float", "min": 0.1, "default": 1, "label": "Mesh Width", "description": "Width of the mesh net" },
    "meshNodeSize": { "type": "float", "min": 1, "default": 5, "label": "Mesh Node Size", "description": "Width of the mesh nodes" },
    "trussTop": { "type": "float", "min": 1, "default": 480, "label": "Truss Top", "description": "Truss column height" }
  },

  "ui": {
    "mesh": {
      "type": "uniformFill",
      "color": "0xff000000",
      "vertices": [
<?php
$vertices = array();

// Cube faces
$vertices []= "\n\n// Cube";
for ($x = 0; $x < 50; ++$x) {
  $isDoor = ($x >= 20) && ($x < 30);
  $pixels = $isDoor ? 34 : 45;
  $base = $isDoor ? '($cubeTop - $nodeSpacing * '.($pixels-1).')' : 0;

  // Front
  $vertices []= '{ "type": "rect", "x": "$nodeInset-0.5*$meshWidth + '.$x.'*$nodeSpacing", "z": "$meshInset", "y": "'.$base.'", "width": "$meshWidth", "height": "$trussTop - '.$base.'" }';
  $vertices []= '{ "type": "rect", "instances": "'.$pixels.'", "x": "$nodeInset-0.5*$meshNodeSize + '.$x.'*$nodeSpacing", "y": "$cubeTop - $instance * $nodeSpacing - 0.5 * $meshNodeSize", "z": "$meshInset", "width": "$meshNodeSize", "height": "$meshNodeSize" }';

  // Right
  $vertices []= '{ "type": "rect", "axis": "zy", "x": "$cubeSide - $meshInset", "z": "$nodeInset-0.5*$meshWidth + '.$x.'*$nodeSpacing", "y": "'.$base.'", "width": "$meshWidth", "height": "$trussTop - '.$base.'" }';
  $vertices []= '{ "type": "rect", "instances": "'.$pixels.'", "axis": "zy", "x": "$cubeSide - $meshInset", "z": "$nodeInset-0.5*$meshNodeSize + '.$x.'*$nodeSpacing", "y": "$cubeTop - $instance * $nodeSpacing - 0.5 * $meshNodeSize", "width": "$meshNodeSize", "height": "$meshNodeSize" }';

  // Back
  $vertices []= '{ "type": "rect", "x": "$nodeInset-0.5*$meshWidth + '.$x.'*$nodeSpacing", "z": "$cubeSide - $meshInset", "y": "'.$base.'", "width": "$meshWidth", "height": "$trussTop - '.$base.'" }';
  $vertices []= '{ "type": "rect", "instances": "'.$pixels.'", "x": "$nodeInset-0.5*$meshNodeSize + '.$x.'*$nodeSpacing", "y": "$cubeTop - $instance * $nodeSpacing - 0.5 * $meshNodeSize", "z": "$cubeSide - $meshInset", "width": "$meshNodeSize", "height": "$meshNodeSize" }';

  // Left
  $vertices []= '{ "type": "rect", "axis": "zy", "x": "$meshInset", "z": "$nodeInset-0.5*$meshWidth + '.$x.'*$nodeSpacing", "y": "'.$base.'", "width": "$meshWidth", "height": "$trussTop - '.$base.'" }';
  $vertices []= '{ "type": "rect", "instances": "'.$pixels.'", "axis": "zy", "x": "$meshInset", "z": "$nodeInset-0.5*$meshNodeSize + '.$x.'*$nodeSpacing", "y": "$cubeTop - $instance * $nodeSpacing - 0.5 * $meshNodeSize", "width": "$meshNodeSize", "height": "$meshNodeSize" }';
}

// Cylinder
$vertices []= "\n\n// Cylinder";
for ($a = 0; $a < 120; ++$a) {
  $angle = deg2rad(3 * $a);
  $sin = round(sin($angle), 4);
  $cos = round(cos($angle), 4);

  $isDoor = (($a + 20) % 30) < 10;
  $pixels = $isDoor ? 32 : 43;
  $yb = $isDoor ? '($cubeTop - '.($pixels-1).'* $nodeSpacing)' : 0;

  // Base X/Z position
  $xb = '($cubeSide * 0.5 + ($cylinderRadius - $meshInset) * '.$sin.')';
  $zb = '($cubeSide * 0.5 - ($cylinderRadius - $meshInset) * '.$cos.')';

  // Origin X/Z position of mesh rect
  $xo = '(-'.$cos.' * 0.5 * $meshWidth)';
  $zo = '(-'.$sin.' * 0.5 * $meshWidth)';

  // Origin X/Z position of mesh nodes
  $xno = '(-'.$cos.' * 0.5 * $meshNodeSize)';
  $zno = '(-'.$sin.' * 0.5 * $meshNodeSize)';

  $v1 = '{ "x": "'.$xb.' - '.$xo.'", "y": "'.$yb.'", "z": "'.$zb.' - '.$zo.'" }';
  $v2 = '{ "x": "'.$xb.' + '.$xo.'", "y": "'.$yb.'", "z": "'.$zb.' + '.$zo.'" }';
  $v3 = '{ "x": "'.$xb.' - '.$xo.'", "y": "$cubeTop", "z": "'.$zb.' - '.$zo.'" }';
  $v4 = '{ "x": "'.$xb.' + '.$xo.'", "y": "$cubeTop", "z": "'.$zb.' + '.$zo.'" }';

  $vertices []= $v1;
  $vertices []= $v2;
  $vertices []= $v3;
  $vertices []= $v3;
  $vertices []= $v2;
  $vertices []= $v4;

  for ($p = 0; $p < $pixels; ++$p) {
    $yb = '($cubeTop - '.($p+2).' * $nodeSpacing - 0.5 * $meshNodeSize)';
    $yt = '($cubeTop - '.($p+2).' * $nodeSpacing + 0.5 * $meshNodeSize)';

    $v1 = '{ "x": "'.$xb.' - '.$xno.'", "y": "'.$yb.'", "z": "'.$zb.' - '.$zno.'" }';
    $v2 = '{ "x": "'.$xb.' + '.$xno.'", "y": "'.$yb.'", "z": "'.$zb.' + '.$zno.'" }';
    $v3 = '{ "x": "'.$xb.' - '.$xno.'", "y": "'.$yt.'", "z": "'.$zb.' - '.$zno.'" }';
    $v4 = '{ "x": "'.$xb.' + '.$xno.'", "y": "'.$yt.'", "z": "'.$zb.' + '.$zno.'" }';

    $vertices []= $v1;
    $vertices []= $v2;
    $vertices []= $v3;
    $vertices []= $v3;
    $vertices []= $v2;
    $vertices []= $v4;
  }

}

echo implode(",\n", $vertices);
echo "\n";
?>
      ]
    }
  }
}
